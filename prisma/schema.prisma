generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // or "mysql" or "sqlite"
  url      = env("DATABASE_URL") // Add your database URL to .env file
}

model User {
  id                      Int             @id @default(autoincrement())
  name                    String          @db.VarChar(50)
  email                   String          @unique
  emailVerified           Boolean         @default(false)
  verificationCode        String?
  verificationCodeExpires DateTime?
  resetCode               String?
  resetCodeExpires        DateTime?
  phone                   String          @default("+201000000000") @db.VarChar(20)
  gender                  Gender          @default(MALE)
  country                 String          @default("Egypt") @db.VarChar(100)
  specialization          String          @default("Other") @db.VarChar(100)
  experienceLevel         ExperienceLevel @default(BEGINNER)
  bio                     String?         @db.Text
  signup_method           SignupMethod    @default(MANUAL)

  // Existing relations and fields
  password   String?
  googleId   String?            @unique
  linkedinId String?            @unique
  chats      ChatParticipants[]
  messages   Message[]
  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @updatedAt

  sessionsRequested Session[] @relation(name: "RequesterRelation")
  sessionsReceived  Session[] @relation(name: "RequestedRelation")
}

enum Gender {
  MALE
  FEMALE
}

enum ExperienceLevel {
  BEGINNER
  INTERMEDIATE
  EXPERT
}

enum SignupMethod {
  MANUAL
  GOOGLE
  LINKEDIN
}

model Chat {
  id           String             @id @default(uuid()) // Unique chat ID
  type         ChatType           @default(DIRECT) // Supports direct & group chats
  participants ChatParticipants[]
  messages     Message[]
  createdAt    DateTime           @default(now())
}

model ChatParticipants {
  id       String   @id @default(uuid())
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId   Int
  chat     Chat     @relation(fields: [chatId], references: [id])
  chatId   String
  joinedAt DateTime @default(now())

  @@unique([userId, chatId]) // Ensures a user can be in a chat only once
}

model Message {
  id        String      @id @default(uuid()) // Unique message ID
  chat      Chat        @relation(fields: [chatId], references: [id])
  chatId    String
  sender    User        @relation(fields: [senderId], references: [id], onDelete: Cascade)
  senderId  Int
  content   String // Text message content
  type      MessageType @default(TEXT) // Supports different message types
  read      Boolean     @default(false) // Read receipt
  createdAt DateTime    @default(now())

  @@index([chatId]) // Optimizes message retrieval for a chat
}

enum ChatType {
  DIRECT // One-on-one chat
  GROUP // Group chat (Future feature)
}

enum MessageType {
  TEXT // Plain text
  IMAGE // Image message
  VIDEO // Video message
  AUDIO // Audio message
  FILE // File attachment
}

model Session {
  id            String        @id @default(uuid())
  requesterId   Int           @map("requester_id") // User who initiates
  requestedId   Int           @map("requested_id") // User who is invited
  status        SessionStatus @default(PENDING)
  googleMeetUrl String? // Null until accepted
  scheduledAt   DateTime
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  requester User @relation(name: "RequesterRelation", fields: [requesterId], references: [id], onDelete: Cascade)
  requested User @relation(name: "RequestedRelation", fields: [requestedId], references: [id], onDelete: Cascade)
}

enum SessionStatus {
  PENDING
  ACCEPTED
  REJECTED
}
